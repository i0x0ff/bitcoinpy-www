[{"body":"These docs consists of a list of maintained and up-to-date Bitcoin Python libraries. Goal is to provide a solid starting point for Python developers willing to work and interact with Bitcoin protocol. Weather it's constructing transactions or fetching data from a Bitcoin RPC server.\nRunning Bitcoin Bitcoin node can be ran on several networks (mainet, testnet, signet, regtest). Under this section you'll learn how to setup and run a Bitcoin node which you can then use as a \u0026quot;portal\u0026quot; into the Bitcoin protocol. Read more\nLibraries python-bitcoinlib Python3 library providing an interface to Bitcoin data structures and protocol. Read more\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\nbuidl Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage. Read more\nLibrary only supports mainnet, testnet and signet and requires internet to work.\n","link":"https://bitcoinpy.dev/docs/","title":"Overview"},{"body":"We assume you're running a Bitcoin node on Regtest. In case you're not and you're not sure how to configure your Bitcoin node to run on Regtest have a look at this guide.\nGenerate address 1bitcoin-cli getnewaddress Generate (mine) blocks bitcoin-cli generatetoaddress \u0026lt;number of blocks\u0026gt; \u0026lt;youraddress\u0026gt;\n1bitcoin-cli generatetoaddress 50 bcrt1qywrq947s5yjjn7ye45y9wwh3g093cvec5fl9gn Note that after genering blocks the \u0026quot;mining\u0026quot; rewards can not be usued until they have matured. Rewards are considered matured after 100 confirmations. Our above example command generated 50 blocks which means the rewards are still immature so you'll need to generate more blocks.\n","link":"https://bitcoinpy.dev/docs/running-bitcoin/regtest-guide/","title":"Regtest Guide"},{"body":"Running Bitcoin is easy. This section with show you how to get your node up and running.\nInstallating We'll be install Bitcoin binary files here. In case you'd prefer to build and install Bitcoin from source have a look at a relevant build- file for your operating system.\nBelow steps are intended for users running Linux. We might add guides for other OS in the future.\n Download a relevant file from: https://bitcoincore.org/en/download/ Extract the files: tar xvzf bitcoin-22.0-x86_64-linux-gnu.tar.gz Verify your download Copy binary files to local bin directory so they can be accessed from anywhere, eg: sudo cp bitcoin-22.0/bin/* /usr/local/bin/  Configuring Now that you have successfully installed Bitcoin, we'll go ahead with the configuration.\nBitcoin node can run on several networks:\n mainnet: main (production) network, these is the only network where coins have value testnet: public testnet network with a long history where things are tested, this network mimics mainnet as much as possible which is why it's based on PoW signet: new type of public testnet network with centralized consensus where a dedicated entity or a group with authority to create new blocks can produce new blocks using valid signatures (not PoW based) regtest: private (sandboxed) version of testnet for individual developers where developer himself has a full control (spinning up and connecting nodes, minig blocks (no actualy PoW needed), triggering manual reorgs etc.)  During this configuration we will guide you to configure a node that will connect to testnet. Later on we will explain how to connect to other networks.\n1. Create configuration file  Create a .bitcoin folder in your home directory: mkdir ~/.bitcoin Create a bitcoin.conf file to this directory: touch .bitcoin/bitcoin.conf  By default all bitcoin binaries read the configuration from ~/.bitcoin/bitcoin.conf path.\n2. Setup configuration file For more info about specific configuration parameters visit bitcoin.conf example file and jlopp's config generator.\n1# Generated by https://jlopp.github.io/bitcoin-core-config-generator/ 2 3# This config should be placed in following path: 4# ~/.bitcoin/bitcoin.conf 5 6# [chain] 7# Run this node on the Bitcoin Test Network. Equivalent to -chain=test 8testnet=1 9 10# [debug] 11# Enable debug logging for all categories. 12debug=1 13 14# [network] 15# Automatically create Tor hidden service. 16listenonion=0 17 18# [rpc] 19# Accept command line and JSON-RPC commands. 20server=1 21rpcuser=user-change-me 22rpcpassword=password-change-me 23 24 25# [Sections] 26# Most options automatically apply to mainnet, testnet, and regtest networks. 27# If you want to confine an option to just one network, you should add it in the relevant section. 28# EXCEPTIONS: The options addnode, connect, port, bind, rpcport, rpcbind and wallet 29# only apply to mainnet unless they appear in the appropriate section below. 30 31# Options only for mainnet 32[main] 33 34# Options only for testnet 35[test] 36 37# Options only for regtest 38[regtest] 39 40# Options only for signet 41[regtest] 3. Run Bitcoin You can start the node by running bitcoind. You should see youre node booting up and starting to sync. Syncing on testnet takes a few hours and with our configuration it will eat up around 40gb of disk space.\nIf you'd prefer to start a bitcoind as a background process you need to run it with daemon mode enabled eg: bitcoind -daemon. To see output as you did before you can see the logs in .bitcoin/testnet3/debug.log.\nCongratulations ðŸŽ‰ You're running Bitcoin.\nRun on other networks In order to connect to networks other than testnet (the one we used in the example config file), you'll need to make some modifications.\nMainnet Modify the config:\n Under [chain] replace testnet=1 with mainnet=1.  1# [chain] 2mainnet=1 Signet Modify the config:\n Under [chain] replace testnet=1 with signet=1.  1# [chain] 2signet=1 Regtest Modify the config:\n Under [chain] replace testnet=1 with regtest=1.  1# [chain] 2regtest=1 Add the following to the bitcoin.conf file  1# [relay] 2minrelaytxfee=0.00001 ","link":"https://bitcoinpy.dev/docs/running-bitcoin/","title":"Running Bitcoin"},{"body":" Library supports mainnet, testnet and signet and requires internet to work.  Despite this section being called Transactions, it will actually show how to generate specific types of Bitcoin addresses and then make a transaction to spend the funds that each specific address type will hold.\nBitcoin doesn't actually have transaction types but has different types of addresses. Each type of address has a different way of \u0026quot;unlocking\u0026quot; its funds. The way that dictates how to unlock funds is set (or scripted) at the time when the address is generated.\nBellow are a different types of addresses and way how to spend funds from those addresses. In the code samples we will be using RegTest network which makes trying out things faster as we can generate blocks on demand.\nP2WPKH P2WPKH is an abbreviation for Pay to Witness Public Key Hash. P2WPKH is the native Segwit version of a P2PKH.\nP2WPKH has the same semantics as P2PKH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input.\nscriptPubKey: 0 \u0026lt;witnessPubKeyHash\u0026gt;\nGenerate address 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.bech32_address(\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: tb1q08alc0e5ua69scxhvyma568nvguqccrvl7rkgx Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;5375b209e02aa4fd665b10fbbfbd5bbe3045a307ddcabd7571f87ab571a41e98\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 23 24redeem_script = private_key.point.p2sh_p2wpkh_redeem_script() 25 26# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 27tx.sign_input(0, private_key, redeem_script=redeem_script) 28 29# Done! Print the transaction 30print(tx.serialize().hex()) 31# outputs: 01000000000101981ea471b57af87175bdcadd07a34530be5bbdbffb105b66fda42ae009b275530100000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b02483045022100ca58968430508ce0a36b45c7ad53de85fbf111569ed822d69844fc232df9a7a6022011445083ce81f4cce1e8bc4a82b8338f9025de080dfb7e202352fe66411d117f01210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was d1be307fe1d50d1e0044ba6b031cf0ad7d105d4d7d1d1cc6a4abff8dd225386f.\nP2WSH P2WSH is an abbreviation for Pay to Witness Script Hash. P2WSH is the native Segwit version of a P2SH.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WSH has the same semantics as P2SH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input. Script Hash allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins.\nscriptPubKey: 0 \u0026lt;witnessScriptHash\u0026gt;\nwitnessScriptHash: sha256(pubKey OP_CHECKSIG)\nBelow are two types of examples; for singlesig and multisig. Singlesig means only one signature can unlock the funds in the address and multisig means multiple signatures are needed to unlock the funds.\nThe example for singlesig should only serve as an example. We don't recommend using it in the real world because it is not its intention to be used for addresses with single signatures.\n Generate address (singlesig) 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 9 10h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 11private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 12 13# Create a witnessScript and corresponding redeemScript. Similar to a scriptPubKey 14# the redeemScript must be satisfied for the funds to be spent. 15redeem_script = WitnessScript([private_key.point.sec(), 0xac]) 16 17address = redeem_script.address(\u0026#34;signet\u0026#34;) 18print(\u0026#39;Address:\u0026#39;, str(address)) 19# outputs: tb1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqtuzpzy Spend from address (singlesig) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;f24d3d8c85ded6d0fbe898a09a2c9f8a8388e4edcf139e52c8714814d85f8273\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 23 24sig1 = tx.get_sig_segwit(0, private_key, witness_script=redeem_script) 25 26tx.check_sig_segwit( 27 0, 28 private_key.point, 29 Signature.parse(sig1[:-1]), 30 witness_script=redeem_script, 31) 32 33txin.witness = Witness([sig1, redeem_script.raw_serialize()]) 34 35print(tx.serialize().hex()) 36# outputs: 0100000000010173825fd8144871c8529e13cfede488838a9f2c9aa098e8fbd0d6de858c3d4df20000000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b0247304402201b812e3a58b18bf83ee65db660af469708583073beaecbd4d7147757068e5ece022034a0b51dc40cdbcba1362f544a467e3dc605395f5e0029d5d2e342aea1ddfac20123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 19e8dc2d719e14bc652bda4809007a72c17bdee6e174d4c02f570c48cad691cd.\nGenerate address (multisig) todo\nSpend from address (multisig) todo\nP2PKH P2PKH is an abbreviation for Pay to Public Key Hash.\nscriptPubKey: OP_DUP OP_HASH160 \u0026lt;pubKeyHash\u0026gt; OP_EQUALVERIFY OP_CHECKSIG\nGenerate address 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.address(network=\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;06633b187444530eb74284730e45c00946b7f83c4acca5213037e44406b0dceb\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 23 24# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 25tx.sign_p2pkh(0, private_key) 26 27# Done! Print the transaction 28print(tx.serialize().hex()) 29# outputs: 0100000001ebdcb00644e4373021a5cc4a3cf8b74609c0450e738442b70e534474183b6306010000006a4730440220026f57ed7143868dba36b4bc3123719a9a4bb65a479ab2e086de9f93e4c43f1c02204943c6e5ead4de886aa1b4777cffa072a21c8d4c13743543d1a4e1f06ab28d0301210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was ee002c8a2d9a791382600c5e9526faf173c60827abde4f34dd2267d480aa66bd.\nP2SH P2SH is an abbreviation for Pay to Script Hash. It allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  scriptPubKey: OP_HASH160 \u0026lt;scriptHash\u0026gt; OP_EQUAL\nBelow are two types of examples; for singlesig and multisig. Singlesig means only one signature can unlock the funds in the address and multisig means multiple signatures are needed to unlock the funds.\nThe example for singlesig should only serve as an example. We don't recommend using it in the real world because it is not its intention to be used for addresses with single signatures.\n Generate address (singlesig) 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int, SIGHASH_ALL, int_to_byte 6from buidl.script import P2PKHScriptPubKey, RedeemScript, Script, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11 12# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be satisfied for the funds 13# to be spent. 14redeem_script = RedeemScript([private_key.point.sec(), 0xac]) 15address = redeem_script.address(\u0026#34;signet\u0026#34;) 16print(\u0026#34;Address\u0026#34;, address) 17# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (singlesig) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;65665709c7d83b7efb8e58f5c6e08a3ebefd752dd83d7af9e0022b13388c3780\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) #, segwit=True) 23 24sighash = tx.sig_hash_legacy(0, redeem_script) 25 26# signed sighash 27signed_sighash = private_key.sign(sighash).der() + int_to_byte(SIGHASH_ALL) 28 29txin.script_sig = Script([signed_sighash, redeem_script.raw_serialize()]) 30 31tx.check_sig_legacy( 32 0, 33 private_key.point, 34 Signature.parse(signed_sighash[:-1]), 35 redeem_script=redeem_script, 36) 37 38# Done! Print the transaction 39print(tx.serialize().hex()) 40# outputs: 010000000180378c38132b02e0f97a3dd82d75fdbe3e8ae0c6f5588efb7e3bd8c709576665010000006c473044022040048e65bb5a58c69d9f514472b5d581f83105422210c134edf20c2ba1d2be50022029069037cc852b83b341a397c0a753bbaf6aefee9e9455483ffaa39666784ad80123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 9987191906843b5c99218cbae7f73d0ae85c0b62b78fdaf9755eb6a4a9856858.\nGenerate address (multisig) todo\nSpend from address (multisig) todo\n Sources:\n https://learnmeabitcoin.com https://wiki.trezor.io https://bitcoindev.network  ","link":"https://bitcoinpy.dev/docs/buidl/transactions/","title":"Transactions"},{"body":" Library supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.  Despite this section being called Transactions, it will actually show how to generate specific types of Bitcoin addresses and then make a transaction to spend the funds that each specific address type will hold.\nBitcoin doesn't actually have transaction types but has different types of addresses. Each type of address has a different way of \u0026quot;unlocking\u0026quot; its funds. The way that dictates how to unlock funds is set (or scripted) at the time when the address is generated.\nBellow are a different types of addresses and way how to spend funds from those addresses. In the code samples we will be using RegTest network which makes trying out things faster as we can generate blocks on demand.\nP2WPKH P2WPKH is an abbreviation for Pay to Witness Public Key Hash. P2WPKH is the native Segwit version of a P2PKH.\nP2WPKH has the same semantics as P2PKH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input.\nscriptPubKey: 0 \u0026lt;witnessPubKeyHash\u0026gt;\nGenerate address 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, b2lx, lx, COIN, COutPoint, CTxOut, CTxIn, CTxInWitness, CTxWitness, CScriptWitness, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_0, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, P2WPKHBitcoinAddress, CBitcoinAddress 7from bitcoin.rpc import Proxy 8 9SelectParams(\u0026#34;regtest\u0026#34;) 10 11 12# Create the (in)famous correct brainwallet secret key. 13h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 14seckey = CBitcoinSecret.from_secret_bytes(h) 15 16# Create an address from that private key. 17public_key = seckey.pub 18scriptPubKey = CScript([OP_0, Hash160(public_key)]) 19address = P2WPKHBitcoinAddress.from_scriptPubKey(scriptPubKey) 20print(\u0026#39;Address:\u0026#39;, str(address)) 21# outputs: Address: bcrt1q08alc0e5ua69scxhvyma568nvguqccrvah6ml0 Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;f11a1f8c9f1dba811b516e41ddf9159428728d4e98b57dff798619604021b88f\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qvg69hl7uj3y4x3xpy8dq2rrfdhq4nwmzpx9s6y\u0026#34;).to_scriptPubKey() 19 20# Create the unsigned transaction. 21txin = CTxIn(COutPoint(txid, vout)) 22txout = CTxOut(amount_less_fee, destination) 23tx = CMutableTransaction([txin], [txout]) 24 25# Calculate the signature hash for that transaction. 26sighash = SignatureHash( 27 script=address.to_redeemScript(), 28 txTo=tx, 29 inIdx=0, 30 hashtype=SIGHASH_ALL, 31 amount=amount, 32 sigversion=SIGVERSION_WITNESS_V0, 33) 34signature = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 35 36# Construct a witness for this transaction input. The public key is given in 37# the witness so that the appropriate redeem_script can be calculated by 38# anyone. The original scriptPubKey had only the Hash160 hash of the public 39# key, not the public key itself, and the redeem script can be entirely 40# re-constructed (from implicit template) if given just the public key. So the 41# public key is added to the witness. This is P2WPKH in bip141. 42witness = [signature, public_key] 43 44# Aggregate all of the witnesses together, and then assign them to the 45# transaction object. 46ctxinwitnesses = [CTxInWitness(CScriptWitness(witness))] 47tx.wit = CTxWitness(ctxinwitnesses) 48 49# Done! Print the transaction 50print(b2x(tx.serialize())) 51# outputs: 010000000001018fb8214060198679ff7db5984e8d72289415f9dd416e511b81ba1d9f8c1f1af10100000000ffffffff01c09ee6050000000016001462345bffdc94495344c121da050c696dc159bb620247304402200f6ecd46b0b3893a955f29a976fbf2eeb1b9a085ce9873ce678faf04504ed4e902207544896b9f17c2b77ec8bc8416d94b2e2043c7917549e48dfacd1a6f2e6b421b01210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 210dde7106e38bc8bf761002714e7bd636ee0d5b2dd355327e5dac73b81a68da.\nP2WSH P2WSH is an abbreviation for Pay to Witness Script Hash. P2WSH is the native Segwit version of a P2SH.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WSH has the same semantics as P2SH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input. Script Hash allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins.\nscriptPubKey: 0 \u0026lt;witnessScriptHash\u0026gt;\nwitnessScriptHash: sha256(pubKey OP_CHECKSIG)\nBelow are two types of examples; for singlesig and multisig. Singlesig means only one signature can unlock the funds in the address and multisig means multiple signatures are needed to unlock the funds.\nThe example for singlesig should only serve as an example. We don't recommend using it in the real world because it is not its intention to be used for addresses with single signatures.\n Generate address (singlesig) 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_CHECKSIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 7 8# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a witnessScript and corresponding redeemScript. Similar to a scriptPubKey 16# the redeemScript must be satisfied for the funds to be spent. 17redeemScript = CScript([seckey.pub, OP_CHECKSIG]) 18scriptHash = hashlib.sha256(redeemScript).digest() 19scriptPubKey = CScript([OP_0, scriptHash]) 20 21# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 22# You\u0026#39;ll need to send some funds to it to create a txout to spend. 23address = P2WSHBitcoinAddress.from_scriptPubKey(scriptPubKey) 24print(\u0026#39;Address:\u0026#39;, str(address)) 25# outputs: Address: bcrt1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqx9g8h7 Spend from address (singlesig) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;06d72b86c6200f5721c5de22e77a4e9fa5942eeb64d9ccb8232855575eaacec7\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q5j2zfz4gqe6kd68w9m4ed42n5v2qhfkapqadf0\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26 script=redeemScript, 27 txTo=tx, 28 inIdx=0, 29 hashtype=SIGHASH_ALL, 30 amount=amount, 31 sigversion=SIGVERSION_WITNESS_V0, 32) 33 34# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 37 38# Construct a witness for this P2WSH transaction and add to tx. 39witness = CScriptWitness([sig, redeemScript]) 40tx.wit = CTxWitness([CTxInWitness(witness)]) 41 42# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 01000000000101c7ceaa5e57552823b8ccd964eb2e94a59f4e7ae722dec521570f20c6862bd7060000000000ffffffff01c09ee60500000000160014a494248aa8067566e8ee2eeb96d553a3140ba6dd02473044022031e858a32ab783a5a1c991b1dc67439d00ac5309ea9c7a144dd742835d9a5abe022030f0142bc37886a0cb73fc7d3701d57b682b12328af0f50bc511089f269e9c010123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 2f033335f99298cefa1895c399b2ab41f0dd1c9141b746159b2f9416dab53133.\nGenerate address (multisig) todo\nSpend from address (multisig) todo\nP2PKH P2PKH is an abbreviation for Pay to Public Key Hash.\nscriptPubKey: OP_DUP OP_HASH160 \u0026lt;pubKeyHash\u0026gt; OP_EQUALVERIFY OP_CHECKSIG\nGenerate address 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret, P2PKHBitcoinAddress 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15public_key = seckey.pub 16address = P2PKHBitcoinAddress.from_pubkey(public_key) 17print(\u0026#39;Address:\u0026#39;, str(address)) 18# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;c36a4408a242402cb1584e640a5cbe883513a78aae0cf8ea02986cc76845e9e0\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# We also need the scriptPubKey of the output we\u0026#39;re spending because 18# SignatureHash() replaces the transaction scriptSig\u0026#39;s with it. 19# 20# Here we\u0026#39;ll create that scriptPubKey from scratch using the pubkey that 21# corresponds to the secret key we generated above. 22scriptPubKey = CScript([OP_DUP, OP_HASH160, Hash160(seckey.pub), OP_EQUALVERIFY, OP_CHECKSIG]) 23 24destination = CBitcoinAddress(\u0026#39;bcrt1q05cfmjm79ujnnpe2r8wr5kv3kcrtsq3jec3n0l\u0026#39;).to_scriptPubKey() 25 26# Create the txout. This time we create the scriptPubKey from a Bitcoin address. 27txout = CMutableTxOut(amount_less_fee, destination) 28 29# Create the unsigned transaction. 30tx = CMutableTransaction([txin], [txout]) 31 32# Calculate the signature hash for that transaction. 33sighash = SignatureHash(scriptPubKey, tx, 0, SIGHASH_ALL) 34 35# Now sign it. We have to append the type of signature we want to the end, in 36# this case the usual SIGHASH_ALL. 37sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 38 39# Set the scriptSig of our transaction input appropriately. 40txin.scriptSig = CScript([sig, seckey.pub]) 41 42# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 0100000001e0e94568c76c9802eaf80cae8aa7133588be5c0a644e58b12c4042a208446ac3000000006b4830450221009abd104d04ecf518c288979ce387defe2ac1d25cb2cf4b3cd97f54e182ef0c3c022055a558c31bcb79237bb75a6659d07eee7875046693818d6f6f0e6064e733c72401210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01c09ee605000000001600147d309dcb7e2f2539872a19dc3a5991b606b8023200000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was cd6bac96d5f43afaa3663647ed7e7301925ac7760d0d22f1fb7f540a7c080dd7.\nP2SH P2SH is an abbreviation for Pay to Script Hash. It allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  scriptPubKey: OP_HASH160 \u0026lt;scriptHash\u0026gt; OP_EQUAL\nBelow are two types of examples; for singlesig and multisig. Singlesig means only one signature can unlock the funds in the address and multisig means multiple signatures are needed to unlock the funds.\nThe example for singlesig should only serve as an example. We don't recommend using it in the real world because it is not its intention to be used for addresses with single signatures.\n Generate address (singlesig) 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 16# satisfied for the funds to be spent. 17redeem_script = CScript([seckey.pub, OP_CHECKSIG]) 18 19# Create the magic P2SH scriptPubKey format from that redeemScript. You should 20# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 21# understand what\u0026#39;s happening, as well as read BIP16: 22# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 23script_pubkey = redeem_script.to_p2sh_scriptPubKey() 24 25# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 26# You\u0026#39;ll need to send some funds to it to create a txout to spend. 27address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 28print(\u0026#39;Address:\u0026#39;,str(address)) 29# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (singlesig) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;600bb0135fa78bbf895b5a933bbff0c304f66ba74810cb9f533e358ded2663c5\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qzw44fxmxs2y39uxtl9ql0sxwpspwd0p8rum3nw\u0026#34;).to_scriptPubKey() 19 20# Create the txout. This time we create the scriptPubKey from a Bitcoin address. 21txout = CMutableTxOut(amount_less_fee, destination) 22 23# Create the unsigned transaction. 24tx = CMutableTransaction([txin], [txout]) 25 26# Calculate the signature hash for that transaction. Note how the script we use 27# is the redeemScript, not the scriptPubKey. That\u0026#39;s because when the CHECKSIG 28# operation happens EvalScript() will be evaluating the redeemScript, so the 29# corresponding SignatureHash() function will use that same script when it 30# replaces the scriptSig in the transaction being hashed with the script being 31# executed. 32sighash = SignatureHash(redeem_script, tx, 0, SIGHASH_ALL) 33 34# Now sign it. We have to append the type of signature we want to the end, in 35# this case the usual SIGHASH_ALL. 36sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 37 38# Set the scriptSig of our transaction input appropriately. 39txin.scriptSig = CScript([sig, redeem_script]) 40 41# Done! Print the transaction 42print(b2x(tx.serialize())) 43# outputs: 0100000001c56326ed8d353e539fcb1048a76bf604c3f0bf3b935a5b89bf8ba75f13b00b60010000006d483045022100ec13f326674bc6accef9aa8ec7101d1301d8e33af86fc5737c04d66bf6beaa000220095d38069dc8563edfcfb52c36b7b8334d3c76d4ab07fdcd9635bfaf67b19ba60123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01c09ee6050000000016001413ab549b66828912f0cbf941f7c0ce0c02e6bc2700000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 5cf00f81103b8b0283d98cec2f20421496eba6cc0660b263275e06f142686650.\n1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 16# satisfied for the funds to be spent. 17redeem_script = CScript([seckey.pub, OP_CHECKSIG]) 18 19# Create the magic P2SH scriptPubKey format from that redeemScript. You should 20# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 21# understand what\u0026#39;s happening, as well as read BIP16: 22# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 23script_pubkey = redeem_script.to_p2sh_scriptPubKey() 24 25# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 26# You\u0026#39;ll need to send some funds to it to create a txout to spend. 27address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 28print(\u0026#39;Address:\u0026#39;,str(address)) 29# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Generate address (multisig) todo\nSpend from address (multisig) todo\n Sources:\n https://learnmeabitcoin.com https://wiki.trezor.io https://bitcoindev.network  ","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/transactions/","title":"Transactions"},{"body":" PyPi: https://pypi.org/project/python-bitcoinlib/ Source: GitHub  Python3 library providing an interface to Bitcoin data structures and protocol.\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/","title":"python-bitcoinlib"},{"body":" PyPi: https://pypi.org/project/buidl/ Source: GitHub  Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage.\nLibrary only supports mainnet, testnet and signet and requires internet to work.\n","link":"https://bitcoinpy.dev/docs/buidl/","title":"buidl"},{"body":"Home of Bitcoin Python BitcoinPy is aiming to be the ultimate Python resource for Bitcoin.\nGoal of BitcoinPy is to be a living documentation of Bitcoin related Python libraries and tools, along with code examples of how to interact with Bitcoin using Python.\nGet Started\nIf you notice any issues, misinformation, have a suggestion for new content or have came across a bugs in the code examples...\nOpen a Pull Request or an Issue on GitHub.\n Join #bitcoin-python on Libera Follow the guide on joinin #bitcoin-python on Libera.\n Python shadowy super coders - UNITE!  ","link":"https://bitcoinpy.dev/","title":"BitcoinPy"}]