[{"body":"These docs consists of a list of maintained and up-to-date Bitcoin Python libraries. Goal is to provide a solid starting point for Python developers willing to work and interact with Bitcoin protocol. Weather it's constructing transactions or fetching data from a Bitcoin RPC server.\nRunning Bitcoin Bitcoin node can be ran on several networks (mainet, testnet, signet, regtest). Under this section you'll learn how to setup and run a Bitcoin node which you can then use as a \u0026quot;portal\u0026quot; into the Bitcoin protocol. Read more\nLibraries python-bitcoinlib Python3 library providing an interface to Bitcoin data structures and protocol. Read more\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\nbuidl Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage. Read more\nLibrary only supports mainnet, testnet and signet and requires internet to work.\n","link":"https://bitcoinpy.dev/docs/","title":"Overview"},{"body":"Generate address 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.bech32_address(\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: tb1q08alc0e5ua69scxhvyma568nvguqccrvl7rkgx Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;5375b209e02aa4fd665b10fbbfbd5bbe3045a307ddcabd7571f87ab571a41e98\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 23 24redeem_script = private_key.point.p2sh_p2wpkh_redeem_script() 25 26# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 27tx.sign_input(0, private_key, redeem_script=redeem_script) 28 29# Done! Print the transaction 30print(tx.serialize().hex()) 31# outputs: 01000000000101981ea471b57af87175bdcadd07a34530be5bbdbffb105b66fda42ae009b275530100000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b02483045022100ca58968430508ce0a36b45c7ad53de85fbf111569ed822d69844fc232df9a7a6022011445083ce81f4cce1e8bc4a82b8338f9025de080dfb7e202352fe66411d117f01210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was d1be307fe1d50d1e0044ba6b031cf0ad7d105d4d7d1d1cc6a4abff8dd225386f.\n","link":"https://bitcoinpy.dev/docs/buidl/p2wpkh/","title":"P2WPKH address"},{"body":"Generate address 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, b2lx, lx, COIN, COutPoint, CTxOut, CTxIn, CTxInWitness, CTxWitness, CScriptWitness, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_0, OP_CHECKSIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, P2WPKHBitcoinAddress, CBitcoinAddress 7from bitcoin.rpc import Proxy 8 9SelectParams(\u0026#34;regtest\u0026#34;) 10 11 12# Create the (in)famous correct brainwallet secret key. 13h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 14seckey = CBitcoinSecret.from_secret_bytes(h) 15 16public_key = seckey.pub 17script_pubkey = CScript([OP_0, Hash160(public_key)]) 18address = P2WPKHBitcoinAddress.from_scriptPubKey(script_pubkey) 19 20# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2PKH 21# transaction, however, while the redeemScript of a P2SH transaction is included in the ScriptSig, 22# the WitnessScript is included in the Witness field, making P2WPKH inputs cheaper to spend than 23# P2PKH inputs. 24witness_script = address.to_redeemScript() 25 26print(\u0026#39;Address:\u0026#39;, str(address)) 27# outputs: Address: bcrt1q08alc0e5ua69scxhvyma568nvguqccrvah6ml0 Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;f11a1f8c9f1dba811b516e41ddf9159428728d4e98b57dff798619604021b88f\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qvg69hl7uj3y4x3xpy8dq2rrfdhq4nwmzpx9s6y\u0026#34;).to_scriptPubKey() 19 20# Create the unsigned transaction. 21txin = CTxIn(COutPoint(txid, vout)) 22txout = CTxOut(amount_less_fee, destination) 23tx = CMutableTransaction([txin], [txout]) 24 25# Calculate the signature hash for that transaction. 26sighash = SignatureHash( 27 script=CScript([seckey.pub, OP_CHECKSIG]), 28 txTo=tx, 29 inIdx=0, 30 hashtype=SIGHASH_ALL, 31 amount=amount, 32 sigversion=SIGVERSION_WITNESS_V0, 33) 34signature = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 35 36# Construct a witness for this transaction input. The public key is given in 37# the witness so that the appropriate redeemScript can be calculated by 38# anyone. The original scriptPubKey had only the Hash160 hash of the public 39# key, not the public key itself, and the redeem script can be entirely 40# re-constructed (from implicit template) if given just the public key. So the 41# public key is added to the witness. This is P2WPKH in bip141. 42witness = [signature, public_key] 43 44# Aggregate all of the witnesses together, and then assign them to the 45# transaction object. 46ctxinwitnesses = [CTxInWitness(CScriptWitness(witness))] 47tx.wit = CTxWitness(ctxinwitnesses) 48 49# Done! Print the transaction 50print(b2x(tx.serialize())) 51# outputs: 010000000001018fb8214060198679ff7db5984e8d72289415f9dd416e511b81ba1d9f8c1f1af10100000000ffffffff01c09ee6050000000016001462345bffdc94495344c121da050c696dc159bb620247304402200f6ecd46b0b3893a955f29a976fbf2eeb1b9a085ce9873ce678faf04504ed4e902207544896b9f17c2b77ec8bc8416d94b2e2043c7917549e48dfacd1a6f2e6b421b01210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c7100000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 210dde7106e38bc8bf761002714e7bd636ee0d5b2dd355327e5dac73b81a68da.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2wpkh/","title":"P2WPKH address"},{"body":"Running Bitcoin is easy. This section with show you how to get your node up and running.\nInstallating We'll be install Bitcoin binary files here. In case you'd prefer to build and install Bitcoin from source have a look at a relevant build- file for your operating system.\nBelow steps are intended for users running Linux. We might add guides for other OS in the future.\n Download a relevant file from: https://bitcoincore.org/en/download/ Extract the files: tar xvzf bitcoin-22.0-x86_64-linux-gnu.tar.gz Verify your download Copy binary files to local bin directory so they can be accessed from anywhere, eg: sudo cp bitcoin-22.0/bin/* /usr/local/bin/  Configuring Now that you have successfully installed Bitcoin, we'll go ahead with the configuration.\nBitcoin node can run on several networks:\n mainnet: main (production) network, these is the only network where coins have value testnet: public testnet network with a long history where things are tested, this network mimics mainnet as much as possible which is why it's based on PoW signet: new type of public testnet network with centralized consensus where a dedicated entity or a group with authority to create new blocks can produce new blocks using valid signatures (not PoW based) regtest: private (sandboxed) version of testnet for individual developers where developer himself has a full control (spinning up and connecting nodes, minig blocks (no actualy PoW needed), triggering manual reorgs etc.)  During this configuration we will guide you to configure a node that will connect to testnet. Later on we will explain how to connect to other networks.\n1. Create configuration file  Create a .bitcoin folder in your home directory: mkdir ~/.bitcoin Create a bitcoin.conf file to this directory: touch .bitcoin/bitcoin.conf  By default all bitcoin binaries read the configuration from ~/.bitcoin/bitcoin.conf path.\n2. Setup configuration file For more info about specific configuration parameters visit bitcoin.conf example file and jlopp's config generator.\n1# Generated by https://jlopp.github.io/bitcoin-core-config-generator/ 2 3# This config should be placed in following path: 4# ~/.bitcoin/bitcoin.conf 5 6# [chain] 7# Run this node on the Bitcoin Test Network. Equivalent to -chain=test 8testnet=1 9 10# [debug] 11# Enable debug logging for all categories. 12debug=1 13 14# [network] 15# Automatically create Tor hidden service. 16listenonion=0 17 18# [rpc] 19# Accept command line and JSON-RPC commands. 20server=1 21rpcuser=user-change-me 22rpcpassword=password-change-me 23 24 25# [Sections] 26# Most options automatically apply to mainnet, testnet, and regtest networks. 27# If you want to confine an option to just one network, you should add it in the relevant section. 28# EXCEPTIONS: The options addnode, connect, port, bind, rpcport, rpcbind and wallet 29# only apply to mainnet unless they appear in the appropriate section below. 30 31# Options only for mainnet 32[main] 33 34# Options only for testnet 35[test] 36 37# Options only for regtest 38[regtest] 39 40# Options only for signet 41[regtest] 3. Run Bitcoin You can start the node by running bitcoind. You should see youre node booting up and starting to sync. Syncing on testnet takes a few hours and with our configuration it will eat up around 40gb of disk space.\nIf you'd prefer to start a bitcoind as a background process you need to run it with daemon mode enabled eg: bitcoind -daemon. To see output as you did before you can see the logs in .bitcoin/testnet3/debug.log.\nCongratulations 🎉 You're running Bitcoin.\nRun on other networks In order to connect to networks other than testnet (the one we used in the example config file), you'll need to make some modifications.\nMainnet Modify the config:\n Under [chain] replace testnet=1 with mainnet=1.  1# [chain] 2mainnet=1 Signet Modify the config:\n Under [chain] replace testnet=1 with signet=1.  1# [chain] 2signet=1 Regtest Modify the config:\n Under [chain] replace testnet=1 with regtest=1.  1# [chain] 2regtest=1 Add the following to the bitcoin.conf file  1# [relay] 2minrelaytxfee=0.00001 ","link":"https://bitcoinpy.dev/docs/running-bitcoin/","title":"Running Bitcoin"},{"body":"Bitcoin doesn't actually have different types of transactions but has different types of addresses formats. Each address has a different way of \u0026quot;unlocking\u0026quot; its funds. The way that dictates how to unlock funds is set (or scripted) at the time when the address is generated.\nP2PKH P2PKH is an abbreviation for Pay to Public Key Hash. It locks bitcoins to the hash of a public key, this is most commonly used for payments.\nNote that P2PKH is considered to be a legacy address so P2WPKH should be used instead.\nP2SH P2SH is an abbreviation for Pay to Script Hash. It allows you to lock coins to the hash of a script, and you then provide that original script when you come unlock those coins. P2SH locks bitcoins to the hash of a script, this format enabled more advanced functionalities (eg. MultiSigs, HTLCs etc.).\nNote that P2SH is considered to be a legacy address so P2WSH should be used instead.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WPKH (SegWit) P2WPKH is an abbreviation for Pay to Witness Public Key Hash. P2WPKH is the native Segwit version of a P2PKH.\nP2WPKH has the same semantics as P2PKH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input which as a result makes transactions smaller and cheaper.\nP2WSH (SegWit) P2WSH is an abbreviation for Pay to Witness Script Hash. P2WSH is the native Segwit version of a P2SH.\n\u0026quot;Script Hash addresses\u0026quot; are intended for multisig or other \u0026quot;smart contract\u0026quot; address. If all you wish to do is receive payment to an address (without multisig) it's better to use P2WPKH as it's cheaper to spend from those addresses.  P2WSH has the same semantics as P2SH, except that the signature is not placed at the same location as before. Segregated Witness (SegWit) moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input which as a result makes transactions smaller and cheaper.\nScript Hash allows you to lock coins to the hash of a script, and you then provide that original script when you come to unlock those coins.\nP2TR (Taproot) Locks bitcoins to a script that can be unlocked by a public key or a MAST (Merkelized Alternative Script Tree). MAST expands the flexibility and utility of Bitcoin contracts in an inexpensive and privacy preserving way.\nP2SH-P2WPKH (Wrapped SegWit) \u0026quot;Wrapped\u0026quot; SegWit address for P2WPKH it enables software that doesn't support SegWit natively to be able to send to SegWit addresses. This format is actually P2SH but it uses a native SegWit P2WPKH script as redeem scripts of a P2SH.\nP2SH-P2WSH (Wrapped SegWit) \u0026quot;Wrapped\u0026quot; SegWit address for P2WSH, it enables software that doesn't support SegWit natively to be able to send to SegWit addresses. This format is actually P2SH but it uses a native SegWit P2WSH script as redeem scripts of a P2SH.\n Sources:\n Wrapped Segwit Trezor's Wiki Bitcoin Developer Network  ","link":"https://bitcoinpy.dev/docs/intro-to-transactions/","title":"Intro to Transactions"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 9 10h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 11private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 12 13# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 14# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  15# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  16# inputs. 17witness_script = WitnessScript([private_key.point.sec(), 0xac]) 18 19address = witness_script.address(\u0026#34;signet\u0026#34;) 20print(\u0026#39;Address:\u0026#39;, str(address)) 21# outputs: tb1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqtuzpzy Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;f24d3d8c85ded6d0fbe898a09a2c9f8a8388e4edcf139e52c8714814d85f8273\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 23 24sig1 = tx.get_sig_segwit(0, private_key, witness_script=witness_script) 25 26tx.check_sig_segwit( 27 0, 28 private_key.point, 29 Signature.parse(sig1[:-1]), 30 witness_script=witness_script, 31) 32 33txin.witness = Witness([sig1, witness_script.raw_serialize()]) 34 35print(tx.serialize().hex()) 36# outputs: 0100000000010173825fd8144871c8529e13cfede488838a9f2c9aa098e8fbd0d6de858c3d4df20000000000ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b0247304402201b812e3a58b18bf83ee65db660af469708583073beaecbd4d7147757068e5ece022034a0b51dc40cdbcba1362f544a467e3dc605395f5e0029d5d2e342aea1ddfac20123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 19e8dc2d719e14bc652bda4809007a72c17bdee6e174d4c02f570c48cad691cd.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 9 10# first signature 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 13 14# second signature 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 17 18# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 19# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  20# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  21# inputs. 22witness_script = WitnessScript( 23 [0x52, private_key1.point.sec(), private_key2.point.sec(), 0x52, 0xAE] 24) 25 26address = witness_script.address(\u0026#34;signet\u0026#34;) 27print(\u0026#39;Address:\u0026#39;, str(address)) 28# outputs: tb1qljlyqaexx4mmhpl66e6nqdtagjaht87pghuq6p0f98a765c9uj9susmlvt Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;e810379ffa5ca20a30f2210d93517aef28d3f20e20b920190161d4f6491a0903\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;, segwit=True) 23 24sig1 = tx.get_sig_segwit(0, private_key1, witness_script=witness_script) 25sig2 = tx.get_sig_segwit(0, private_key2, witness_script=witness_script) 26 27tx.check_sig_segwit( 28 0, 29 private_key1.point, 30 Signature.parse(sig1[:-1]), 31 witness_script=witness_script, 32) 33 34tx.check_sig_segwit( 35 0, 36 private_key2.point, 37 Signature.parse(sig2[:-1]), 38 witness_script=witness_script, 39) 40 41txin.finalize_p2wsh_multisig([sig1, sig2], witness_script) 42 43print(tx.serialize().hex()) 44# outputs: 0100000000010103091a49f6d461011920b9200ef2d328ef7a51930d21f2300aa25cfa9f3710e80000000000ffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea90400483045022100b24100d90fdd15d3e694789106f780c4c13f4929ec5cc82445418bedac9dfc93022038f5cc4ade88b41f1398d5f1e31a9d4f9d861f67aa24dff30a6d20e509b591c801483045022100fa9f78c7769010a57aa96939b32fad0d216a1dcf3a1f44a09f0e7b29f56b773402207a795dad938599c920d864001b454ae2f44358f5ac098e913049ea7fd9925cb001475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 6064651b405e0e1d6b5cdc0056c3deda11af3593ca64d43b1cd4abff45b7376b.\n","link":"https://bitcoinpy.dev/docs/buidl/p2wsh-multisig/","title":"P2WSH address (multisig)"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_CHECKSIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 7 8# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 16# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  17# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  18# inputs. 19witness_script = CScript([seckey.pub, OP_CHECKSIG]) 20script_hash = hashlib.sha256(witness_script).digest() 21script_pubkey = CScript([OP_0, script_hash]) 22 23# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 24# You\u0026#39;ll need to send some funds to it to create a txout to spend. 25address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 26print(\u0026#39;Address:\u0026#39;, str(address)) 27# outputs: Address: bcrt1qgatzazqjupdalx4v28pxjlys2s3yja9gr3xuca3ugcqpery6c3sqx9g8h7 Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;06d72b86c6200f5721c5de22e77a4e9fa5942eeb64d9ccb8232855575eaacec7\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q5j2zfz4gqe6kd68w9m4ed42n5v2qhfkapqadf0\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26 script=witness_script, 27 txTo=tx, 28 inIdx=0, 29 hashtype=SIGHASH_ALL, 30 amount=amount, 31 sigversion=SIGVERSION_WITNESS_V0, 32) 33 34# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 37 38# Construct a witness for this P2WSH transaction and add to tx. 39witness = CScriptWitness([sig, witness_script]) 40tx.wit = CTxWitness([CTxInWitness(witness)]) 41 42# Done! Print the transaction 43print(b2x(tx.serialize())) 44# outputs: 01000000000101c7ceaa5e57552823b8ccd964eb2e94a59f4e7ae722dec521570f20c6862bd7060000000000ffffffff01c09ee60500000000160014a494248aa8067566e8ee2eeb96d553a3140ba6dd02473044022031e858a32ab783a5a1c991b1dc67439d00ac5309ea9c7a144dd742835d9a5abe022030f0142bc37886a0cb73fc7d3701d57b682b12328af0f50bc511089f269e9c010123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ac00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 2f033335f99298cefa1895c399b2ab41f0dd1c9141b746159b2f9416dab53133.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, CTxInWitness, CTxWitness 5from bitcoin.core.script import CScript, CScriptWitness, OP_0, OP_2, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL, SIGVERSION_WITNESS_V0 6from bitcoin.wallet import CBitcoinSecret, CBitcoinAddress, P2WSHBitcoinAddress 7 8# We\u0026#39;ll be using regtest throughout this guide 9SelectParams(\u0026#34;regtest\u0026#34;) 10 11# Create the (in)famous correct brainwallet secret key. 12# first signature 13h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 14seckey1 = CBitcoinSecret.from_secret_bytes(h1) 15 16# second signature 17h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 18seckey2 = CBitcoinSecret.from_secret_bytes(h2) 19 20# Create a witnessScript. witnessScript in SegWit is equivalent to redeemScript in P2SH transaction, 21# however, while the redeemScript of a P2SH transaction is included in the ScriptSig, the  22# WitnessScript is included in the Witness field, making P2WSH inputs cheaper to spend than P2SH  23# inputs. 24witness_script = CScript([OP_2, seckey1.pub, seckey2.pub, OP_2, OP_CHECKMULTISIG]) 25script_hash = hashlib.sha256(witness_script).digest() 26script_pubkey = CScript([OP_0, script_hash]) 27 28# Convert the P2WSH scriptPubKey to a base58 Bitcoin address and print it. 29# You\u0026#39;ll need to send some funds to it to create a txout to spend. 30address = P2WSHBitcoinAddress.from_scriptPubKey(script_pubkey) 31print(\u0026#39;Address:\u0026#39;, str(address)) 32# outputs: Address: bcrt1qljlyqaexx4mmhpl66e6nqdtagjaht87pghuq6p0f98a765c9uj9s3f3ee3 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;49ff22c9985c1991791b7a3bd6a2e8d1d6567ca283e0885afdc83bd92f56d1c4\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26 script=witness_script, 27 txTo=tx, 28 inIdx=0, 29 hashtype=SIGHASH_ALL, 30 amount=amount, 31 sigversion=SIGVERSION_WITNESS_V0, 32) 33 34# Now sign it. We have to append the type of signature we want to the end, in this case the usual 35# SIGHASH_ALL. 36sig1 = seckey1.sign(sighash) + bytes([SIGHASH_ALL]) 37sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 38 39# Construct a witness for this P2WSH transaction and add to tx. 40witness = CScriptWitness([b\u0026#34;\u0026#34;, *[sig1, sig2], witness_script]) 41tx.wit = CTxWitness([CTxInWitness(witness)]) 42 43# Done! Print the transaction 44print(b2x(tx.serialize())) 45# outputs: 01000000000101c4d1562fd93bc8fd5a88e083a27c56d6d1e8a2d63b7a1b7991195c98c922ff490000000000ffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd30400483045022100fef9da5dfaea90104f033960b00612753197bf96c69fce097699aff60261aa3402203b72ed27c929125e5aa0066e6f641b7ffaee4bb6e4929a2428e79a2e0ed4f0140148304502210094fca9f85165c024cace7e92a099be3199e427103a971fd6336ce7386bb8fe410220046b043475b72ee5f9fa2872344c689ee9c800031010db0c11fdb57b0d37ab6301475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552ae00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 8a5115099d07455670db03f791f3caf9788bb9eea4a0d5b7133c3ff804d262ac.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2wsh-multisig/","title":"P2WSH address (multisig)"},{"body":" PyPi: https://pypi.org/project/python-bitcoinlib/ Source: GitHub  Python3 library providing an interface to Bitcoin data structures and protocol.\nLibrary supports mainnet, testnet and regtest. A PR for signet has been merged but the version that supports it hasn't been released yet.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/","title":"python-bitcoinlib"},{"body":" PyPi: https://pypi.org/project/buidl/ Source: GitHub  Python3 library with no dependencies. Provides an interface to Bitcoin data structures. There are more functionalities included into this library which are for more advanced use and will be described on this page at later stage.\nLibrary supports mainnet, testnet and signet and requires internet to work.  ","link":"https://bitcoinpy.dev/docs/buidl/","title":"buidl"},{"body":"Generate address 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11address = private_key.point.address(network=\u0026#34;signet\u0026#34;) 12print(\u0026#39;Address:\u0026#39;, str(address)) 13# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;06633b187444530eb74284730e45c00946b7f83c4acca5213037e44406b0dceb\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) 23 24# Sign the transaction (buidl makes a request to the explorer to fetch public key here) 25tx.sign_p2pkh(0, private_key) 26 27# Done! Print the transaction 28print(tx.serialize().hex()) 29# outputs: 0100000001ebdcb00644e4373021a5cc4a3cf8b74609c0450e738442b70e534474183b6306010000006a4730440220026f57ed7143868dba36b4bc3123719a9a4bb65a479ab2e086de9f93e4c43f1c02204943c6e5ead4de886aa1b4777cffa072a21c8d4c13743543d1a4e1f06ab28d0301210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was ee002c8a2d9a791382600c5e9526faf173c60827abde4f34dd2267d480aa66bd.\n","link":"https://bitcoinpy.dev/docs/buidl/p2pkh/","title":"P2PKH address"},{"body":"Generate address 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret, P2PKHBitcoinAddress 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a redeemScript used to unlock bitcoins 16redeem_script = CScript([OP_DUP, OP_HASH160, Hash160(seckey.pub), OP_EQUALVERIFY, OP_CHECKSIG]) 17 18public_key = seckey.pub 19address = P2PKHBitcoinAddress.from_pubkey(public_key) 20print(\u0026#39;Address:\u0026#39;, str(address)) 21# outputs: Address: mrdwvWkma2D6n9mGsbtkazedQQuoksnqJV Spend from address Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;c36a4408a242402cb1584e640a5cbe883513a78aae0cf8ea02986cc76845e9e0\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#39;bcrt1q05cfmjm79ujnnpe2r8wr5kv3kcrtsq3jec3n0l\u0026#39;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. 25sighash = SignatureHash(redeem_script, tx, 0, SIGHASH_ALL) 26 27# Now sign it. We have to append the type of signature we want to the end, in 28# this case the usual SIGHASH_ALL. 29sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 30 31# Set the scriptSig of our transaction input appropriately. 32txin.scriptSig = CScript([sig, seckey.pub]) 33 34# Done! Print the transaction 35print(b2x(tx.serialize())) 36# outputs: 0100000001e0e94568c76c9802eaf80cae8aa7133588be5c0a644e58b12c4042a208446ac3000000006b4830450221009abd104d04ecf518c288979ce387defe2ac1d25cb2cf4b3cd97f54e182ef0c3c022055a558c31bcb79237bb75a6659d07eee7875046693818d6f6f0e6064e733c72401210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71ffffffff01c09ee605000000001600147d309dcb7e2f2539872a19dc3a5991b606b8023200000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was cd6bac96d5f43afaa3663647ed7e7301925ac7760d0d22f1fb7f540a7c080dd7.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2pkh/","title":"P2PKH address"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.bech32 import decode_bech32 5from buidl.helper import decode_base58, big_endian_to_int, SIGHASH_ALL, int_to_byte 6from buidl.script import P2PKHScriptPubKey, RedeemScript, Script, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8 9h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 10private_key = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 11 12# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be satisfied for the funds 13# to be spent. 14redeem_script = RedeemScript([private_key.point.sec(), 0xac]) 15address = redeem_script.address(\u0026#34;signet\u0026#34;) 16print(\u0026#34;Address\u0026#34;, address) 17# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;65665709c7d83b7efb8e58f5c6e08a3ebefd752dd83d7af9e0022b13388c3780\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qqqlcpznqkfa65wqd48mzzghpwzefgpvtvl0a7k\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) #, segwit=True) 23 24sighash = tx.sig_hash_legacy(0, redeem_script) 25 26# signed sighash 27signed_sighash = private_key.sign(sighash).der() + int_to_byte(SIGHASH_ALL) 28 29txin.script_sig = Script([signed_sighash, redeem_script.raw_serialize()]) 30 31tx.check_sig_legacy( 32 0, 33 private_key.point, 34 Signature.parse(signed_sighash[:-1]), 35 redeem_script=redeem_script, 36) 37 38# Done! Print the transaction 39print(tx.serialize().hex()) 40# outputs: 010000000180378c38132b02e0f97a3dd82d75fdbe3e8ae0c6f5588efb7e3bd8c709576665010000006c473044022040048e65bb5a58c69d9f514472b5d581f83105422210c134edf20c2ba1d2be50022029069037cc852b83b341a397c0a753bbaf6aefee9e9455483ffaa39666784ad80123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01b882010000000000160014003f808a60b27baa380da9f62122e170b294058b00000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 9987191906843b5c99218cbae7f73d0ae85c0b62b78fdaf9755eb6a4a9856858.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 2 3from buidl.ecc import PrivateKey, Signature 4from buidl.helper import decode_base58, big_endian_to_int 5from buidl.bech32 import decode_bech32, encode_bech32_checksum 6from buidl.script import P2PKHScriptPubKey, RedeemScript, WitnessScript, P2WPKHScriptPubKey 7from buidl.tx import Tx, TxIn, TxOut 8from buidl.witness import Witness 9 10# first signature 11h = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12private_key1 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 13 14# second signature 15h = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16private_key2 = PrivateKey(secret=big_endian_to_int(h), network=\u0026#34;signet\u0026#34;) 17 18# Create a redeem script 19redeem_script = RedeemScript.create_p2sh_multisig( 20 quorum_m=2, 21 pubkey_hexes=[ 22 private_key1.point.sec().hex(), 23 private_key2.point.sec().hex(), 24 ], 25 sort_keys=False, 26) 27 28address = redeem_script.address(\u0026#34;signet\u0026#34;) 29print(\u0026#39;Address:\u0026#39;, str(address)) 30# outputs: 2N3avDJKpr9c8pkRSYgWAsHSVCmRX3ce3w7 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = bytes.fromhex(\u0026#34;20a58d3d90b0a9758f2e717dfb4195f270323221b8be01b06c95551807654b9c\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7COIN = 100000000 8amount = int(0.001 * COIN) 9 10# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 11# setting on regtest. 12amount_less_fee = int(amount * 0.99) 13 14# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 15# is necessary for spending a P2WSH output. 16txin = TxIn(txid, vout) 17 18# Specify a destination address and create the txout. 19h160 = decode_bech32(\u0026#34;tb1qwp3c26rlgzlq4axergvt04300shexn4f56q5f7\u0026#34;)[2] 20txout = TxOut(amount=amount_less_fee, script_pubkey=P2WPKHScriptPubKey(h160)) 21 22tx = Tx(1, [txin], [txout], 0, network=\u0026#34;signet\u0026#34;) # , segwit=True) 23 24sig1 = tx.get_sig_legacy(0, private_key1, redeem_script=redeem_script) 25sig2 = tx.get_sig_legacy(0, private_key2, redeem_script=redeem_script) 26 27tx.check_sig_segwit( 28 0, 29 private_key1.point, 30 Signature.parse(sig1[:-1]), 31 redeem_script=redeem_script, 32) 33 34tx.check_sig_segwit( 35 0, 36 private_key2.point, 37 Signature.parse(sig2[:-1]), 38 redeem_script=redeem_script, 39) 40 41txin.finalize_p2sh_multisig([sig1, sig2], redeem_script) 42 43print(tx.serialize().hex()) 44# outputs: 01000000019c4b65071855956cb001beb821323270f29541fb7d712e8f75a9b0903d8da52001000000da004730440220470aef78655414f73ca5ae0feec073d49a134ba1bc3b3ea85d2aa864a9735a66022029382bd5f497dc8435f75dff4ebe6cb7205064738487bbfd7099fd3741c61bc901483045022100aa867aeba637ef0aa8f6386e06bcce5010afb081087ab4e3d01ce610f57eaa4702204b50096f8225cac48a93cddab25be1463b160c77605b93556cc215ed83c0d0f301475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552aeffffffff01b882010000000000160014706385687f40be0af4d91a18b7d62f7c2f934ea900000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 8439bee332441a97a5bd01396c95353a26a163287e12bd691e1940b734f77478.\n","link":"https://bitcoinpy.dev/docs/buidl/p2sh-multisig/","title":"P2SH address (multisig)"},{"body":" The example for 1-of-1 should only serve as an example. We don't recommend using it in the real world because it is not its intention. Instead of 1-of-1 use P2PKH!  Generate address (1-of-1) 1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11# Create the (in)famous correct brainwallet secret key. 12h = hashlib.sha256(b\u0026#39;correct horse battery staple\u0026#39;).digest() 13seckey = CBitcoinSecret.from_secret_bytes(h) 14 15# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 16# satisfied for the funds to be spent. 17redeem_script = CScript([seckey.pub, OP_CHECKSIG]) 18 19# Create the magic P2SH scriptPubKey format from that redeemScript. You should 20# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 21# understand what\u0026#39;s happening, as well as read BIP16: 22# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 23script_pubkey = redeem_script.to_p2sh_scriptPubKey() 24 25# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 26# You\u0026#39;ll need to send some funds to it to create a txout to spend. 27address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 28print(\u0026#39;Address:\u0026#39;,str(address)) 29# outputs: Address: 2Msc7itHhx2x8MEkTthvtED9pFC36J7QpQb Spend from address (1-of-1) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;600bb0135fa78bbf895b5a933bbff0c304f66ba74810cb9f533e358ded2663c5\u0026#34;) 4vout = 1 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig 14# defaults to being empty. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1qzw44fxmxs2y39uxtl9ql0sxwpspwd0p8rum3nw\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. Note how the script we use 25# is the redeemScript, not the scriptPubKey. That\u0026#39;s because when the CHECKSIG 26# operation happens EvalScript() will be evaluating the redeemScript, so the 27# corresponding SignatureHash() function will use that same script when it 28# replaces the scriptSig in the transaction being hashed with the script being 29# executed. 30sighash = SignatureHash(redeem_script, tx, 0, SIGHASH_ALL) 31 32# Now sign it. We have to append the type of signature we want to the end, in 33# this case the usual SIGHASH_ALL. 34sig = seckey.sign(sighash) + bytes([SIGHASH_ALL]) 35 36# Set the scriptSig of our transaction input appropriately. 37txin.scriptSig = CScript([sig, redeem_script]) 38 39# Done! Print the transaction 40print(b2x(tx.serialize())) 41# outputs: 0100000001c56326ed8d353e539fcb1048a76bf604c3f0bf3b935a5b89bf8ba75f13b00b60010000006d483045022100ec13f326674bc6accef9aa8ec7101d1301d8e33af86fc5737c04d66bf6beaa000220095d38069dc8563edfcfb52c36b7b8334d3c76d4ab07fdcd9635bfaf67b19ba60123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff01c09ee6050000000016001413ab549b66828912f0cbf941f7c0ce0c02e6bc2700000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 5cf00f81103b8b0283d98cec2f20421496eba6cc0660b263275e06f142686650.\nGenerate address (2-of-2) In this example we show how to create a 2-of-2 multisig address. This means that two signatures are required in order to unlock funds.\n1import hashlib 2 3from bitcoin import SelectParams 4from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 5from bitcoin.core.script import CScript, OP_DUP, OP_0, OP_2, OP_HASH160, OP_EQUALVERIFY, OP_CHECKMULTISIG, SignatureHash, SIGHASH_ALL 6from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH 7from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret 8 9SelectParams(\u0026#39;regtest\u0026#39;) 10 11h1 = hashlib.sha256(b\u0026#39;correct horse battery staple first\u0026#39;).digest() 12seckey1 = CBitcoinSecret.from_secret_bytes(h1) 13 14# second signature 15h2 = hashlib.sha256(b\u0026#39;correct horse battery staple second\u0026#39;).digest() 16seckey2 = CBitcoinSecret.from_secret_bytes(h2) 17 18# Create a redeemScript. Similar to a scriptPubKey the redeemScript must be 19# satisfied for the funds to be spent. 20redeem_script = CScript([OP_2, seckey1.pub, seckey2.pub, OP_2, OP_CHECKMULTISIG]) 21 22# Create the magic P2SH scriptPubKey format from that redeemScript. You should 23# look at the CScript.to_p2sh_scriptPubKey() function in bitcoin.core.script to 24# understand what\u0026#39;s happening, as well as read BIP16: 25# https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki 26script_pubkey = redeem_script.to_p2sh_scriptPubKey() 27 28# Convert the P2SH scriptPubKey to a base58 Bitcoin address and print it. 29# You\u0026#39;ll need to send some funds to it to create a txout to spend. 30address = CBitcoinAddress.from_scriptPubKey(script_pubkey) 31print(\u0026#39;Address:\u0026#39;,str(address)) 32# outputs: Address: 2N3avDJKpr9c8pkRSYgWAsHSVCmRX3ce3w7 Spend from address (2-of-2) Assuming the previously generated address has received funds, we can spend them. In order to spend them, we'll need information about the transaction id (txid) and a vector of an output (vout). You can get both from an explorer or by querying your running Bitcoin node by running listunspent along with some filters:\nbitcoin-cli listunspent 1 9999999 \u0026quot;[\\\u0026quot;address\\\u0026quot;]\u0026quot;\nNote that you must have an address in the watchlist in order to get any output. To add an address to a watchlist run importaddress:\nbitcoin-cli importaddress \u0026lt;address\u0026gt; \u0026quot;\u0026lt;label\u0026gt;\u0026quot; false false\n1# we are continuing the code from above 2 3txid = lx(\u0026#34;55a7cdebf307597fade5327daa6c95bcab6abc200a878ec191c1f3bd0b7664d0\u0026#34;) 4vout = 0 5 6# Specify the amount send to your P2WSH address. 7amount = int(1 * COIN) 8 9# Calculate an amount for the upcoming new UTXO. Set a high fee (5%) to bypass bitcoind minfee 10# setting on regtest. 11amount_less_fee = amount * 0.99 12 13# Create the txin structure, which includes the outpoint. The scriptSig defaults to being empty as 14# is necessary for spending a P2WSH output. 15txin = CMutableTxIn(COutPoint(txid, vout)) 16 17# Specify a destination address and create the txout. 18destination = CBitcoinAddress(\u0026#34;bcrt1q0q579hm06qf655cr6ns274udgf6k9x7nedkeaa\u0026#34;).to_scriptPubKey() 19txout = CMutableTxOut(amount_less_fee, destination) 20 21# Create the unsigned transaction. 22tx = CMutableTransaction([txin], [txout]) 23 24# Calculate the signature hash for that transaction. 25sighash = SignatureHash( 26 script=redeem_script, 27 txTo=tx, 28 inIdx=0, 29 hashtype=SIGHASH_ALL, 30 amount=amount, 31) 32 33# Now sign it. We have to append the type of signature we want to the end, in this case the usual 34# SIGHASH_ALL. 35sig1 = seckey1.sign(sighash) + bytes([SIGHASH_ALL]) 36sig2 = seckey2.sign(sighash) + bytes([SIGHASH_ALL]) 37 38# Construct a witness for this P2WSH transaction and add to tx. 39txin.scriptSig = CScript([OP_0, sig1, sig2, redeem_script]) 40 41# Done! Print the transaction 42print(b2x(tx.serialize())) 43# outputs: 0100000001d064760bbdf3c191c18e870a20bc6aabbc956caa7d32e5ad7f5907f3ebcda75500000000db00483045022100a22bf0495398d87538bb07daf62948572def31d411df6048e92a53b00d35f06c02204583f20a0fcbb6f5a978f32dde6dfadfe11581973eef946bb87e1ce5b164fb3a014830450221008611aacb5ab9efb1f64200800ac8f55bb6a1acbcdaa2d3db7741df6b99c9f6f802202be1a1c4fdcb649f622b25ad88befba4ef23689e07409bffd4a1d63237993dbd01475221038d19497c3922b807c91b829d6873ae5bfa2ae500f3237100265a302fdce87b052103d3a9dff5a0bb0267f19a9ee1c374901c39045fbe041c1c168d4da4ce0112595552aeffffffff01c09ee605000000001600147829e2df6fd013aa5303d4e0af578d4275629bd300000000 Now that we have our signed and encoded transaction, we can broadcast it using sendrawtransaction:\nbitcoin-cli sendrawtransaction \u0026lt;transaction\u0026gt;\nIf the transaction is broadcasted successfully a transaction id will be returned. In this case it was 844dd295da6877b8e7b01fa79f46aedf1b4f21651c0210ebf5e36f2476f2116d.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2sh-multisig/","title":"P2SH address (multisig)"},{"body":"python-bitcoinlib currently does not support Taproot. Github Issue is open here.\n","link":"https://bitcoinpy.dev/docs/python-bitcoinlib/p2tr/","title":"P2TR address"},{"body":"todo\n","link":"https://bitcoinpy.dev/docs/buidl/p2tr/","title":"P2TR address"},{"body":"Home of Bitcoin Python BitcoinPy is aiming to be the ultimate Bitcoin resource for Python developers.\nBitcoinPy is a living documentation of Bitcoin related Python libraries and tools with emphasis on providing code examples how to use Python to develop and interact with Bitcoin.\nGet Started\nIf you notice any issues, misinformation, have a suggestion for new content or have came across a bugs in the code examples...\nOpen a Pull Request or an Issue on GitHub.\n Join #bitcoin-python on Libera Follow the guide on joinin #bitcoin-python on Libera.\nJoin BitcoinPy on Telegram Join the Telegram group.\n Python shadowy super coders - UNITE!  ","link":"https://bitcoinpy.dev/","title":"Bitcoin resource for Python developers"}]